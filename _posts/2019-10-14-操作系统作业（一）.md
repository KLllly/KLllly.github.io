---
layout:     post   				    # 使用的布局（不需要改）
title:      操作系统作业（一） 				# 标题 
subtitle:   "关于物理/逻辑/线性地址、GDT、CPL、映射到线性空间的内容" #副标题
date:       2019-10-14 				# 时间
author:     KLllly 						# 作者
header-img: img/home-gb-o.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 作业
    - 操作系统
---

## 第一题  
**简要解释一下Intel在386中的逻辑地址、线性地址、物理地址，以及他们与分段分页的关系。**

* **物理地址：**加载到内存地址寄存器中的地址，**内存单元的真正地址**。在前端总线上传输的内存地址都是物理内存地址，编号从0开始一直到可用物理内存的最高端。这些数字被北桥(Nortbridge chip)映射到实际的内存条上。物理地址是明确的、最终用在总线上的编号，不必转换，不必分页，也没有特权级检查(no translation, no paging, no privilege checks)。
* **逻辑地址：**CPU所生成的地址。逻辑地址是内部和编程使用的、并不唯一。是由程序产生的和段相关的偏移地址部分。只有在intel实模式下，逻辑地址才和物理地址相等。（因为实模式没有分段和分页机制，cpu不进行自动地址转换）例如，你在进行C语言指针编程中，可以读取指针变量本身值(&操作)，实际上这个值就是逻辑地址，它是相对于你当前进程数据段的地址（偏移地址），不和绝对物理地址相干。应用程式员仅需和逻辑地址打交道，而分段和分页机制对你来说是完全透明的，仅由系统编程人员涉及。应用程式员虽然自己能直接操作内存，那也只能在操作系统给你分配的内存段操作。
* **线性地址：** 是逻辑地址到物理地址变换之间的**中间层**。程式代码会产生逻辑地址，或说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。**如果启用了分页机制，那么线性地址能再经变换以产生一个物理地址。若没有启用分页机制，那么线性地址直接就是物理地址。**Intel 80386的线性地址空间容量为4G（2的32次方即32根地址总线寻址）
* 386架构里，cpu可以处于实模式和保护模式。**实模式下**，cpu指令访问的地址就是物理地址,形式为：段寄存器：偏移。在**保护模式**下，cpu可以使用分段机制和分页机制。**分段机制**下使用的地址就是**逻辑地址**，形式为：段选择子：偏移。**分页机制**下使用的地址就是**线性地址**，形式为：0xXXXXXXXX。无论是逻辑地址还是线性地址，都要被cpu映射成物理地址。**保护模式下必须采用分段机制。在此基础上可采用分页机制。**逻辑地址被转化为线性地址，如果采用分页机制，则该线性地址通过分页机制被映射成物理地址。如果不采用分页机制，则该线性地址就是物理地址。**实模式**下的物理地址只能访问1M以下空间，而**保护模式**下的物理地址可以访问所有32位空间。并且要注意，**物理内存空间只是物理地址空间的一个部分而已。**另外还有一个”**总线地址**“的概念，是从总线设备的角度来说的。在linux系统里，**对cpu来说，物理内存的首地址**是从线性地址的0xc0000000开始的。**而对总线设备来说，物理内存的首地址**可能是从总线地址0x00000000开始，也可能是从另外的总线地址开始，随系统而异。这也是为什么内核里经常有vir_to_phy 和vir_to_bus转换的缘故。

![图片](https://uploader.shimo.im/f/c5gVftb78BAWVBhO.png!thumbnail)
 
## 第二题
**GDT，LDT，GDTR，LDTR，CR0，CR3的含义和作用。**

* **GDT：**是全局描述符表，主要存放操作系统和各任务**公用**的描述符，如公用的数据和代码段描述符、各任务的TSS描述符和LDT描述符。（TSS是任务状态段，存放各个任务私有运行状态信息描述符）
* **LDT：**是局部描述符表，主要存放各个任务的**私有**描述符，如本任务的代码段描述符和数据段描述符等。
* **GDTR：**是一个长度为48bit的**寄存器**，内容为一个32位的基地址和一个16位的段限。其中32位的基址**是指GDT在内存中的地址**。
* **LDTR：**是**局部描述符寄存器**，由一个可见的16位寄存器（段选择子）和一个不可见的描述符寄存器组成（描述符寄存器实际上是一个不可见的高速缓冲区）。

![图片](https://uploader.shimo.im/f/KDLktadhiDcSkh3G.png!thumbnail)

控制寄存器（CR0～CR3）用于控制和确定处理器的操作模式以及当前执行任务的特性，**CR0**中含有控制处理器操作模式和状态的系统控制标志；CR1保留不用；CR2含有导致页错误的线性地址；**CR3**中含有页目录表物理内存基地址，**因此该寄存器也被称为页目录基地址寄存器PDBR（Page-Directory Base address Register）。**

* CR0的4个位：扩展类型位ET、任务切换位TS、仿真位EM和数学存在位MP**用于控制80x86浮点（数学）协处理器的操作。**CR0的ET位（标志）用于选择与协处理器进行通信所使用的协议，即指明系统中使用的是80387还是80287协处理器。TS、MP和EM位用于确定浮点指令或WAIT指令是否应该产生一个设备不存在（Device Not Available，DNA）异常。这个异常可用来仅为使用浮点运算的任务保存和恢复浮点寄存器。对于没有使用浮点运算的任务，这样做可以加快它们之间的切换操作。
* CR3含有**存放页目录表页面的物理地址**，因此CR3也被称为PDBR。因为页目录表页面是页对齐的，所以**该寄存器只有高20位是有效的。而低12位保留供更高级处理器使用，**因此在往CR3中加载一个新值时低12位必须设置为0。
## 第三题
**CPL、DPL、RPL的含义和作用。386的页表项里表示本页是内核页还是用户页的比特位中叫什么名字？作用是什么？**

* RPL: Requested Privilege Level, 请求特权级，是**段选择子里面的bit 0和bit 1位组合**所得的值。RPL说明的是**进程对段访问的请求权限**(Request Privilege Level)，是**对于段选择子而言**的，每个段选择子有自己的RPL，有点像函数参数。**ARPL指令**改目标数据块选择子的RPL为主调程序的CPL。**RPL对每个段来说不是固定的，**两次访问同一段时的RPL可以不同。RPL可能会**削弱CPL的作用**，例如当前CPL=0的进程要访问一个数据段，它把段选择符中的RPL设为3，这样虽然它对该段仍然只有特权为3的访问权限。
* DPL: Descriptor Privilege Level，描述符特权级。DPL**存储在段描述符中**，规定访问该段的权限级别(Descriptor Privilege Level)，**每个段的DPL固定。**当进程访问一个段时，需要进程特权级检查，**一般要求DPL >= max {CPL, RPL}  （**记法：MAX返回的值不能大于DPL就可以访问）
* CPL: Current Privilege Level，当前特权级，是**CS register 里bit 0和bit 1 位组合所得的值.**在某一时刻就只有这个值唯一的代表程序的CPL.CPL是当前进程的权限级别(Current Privilege Level)，是当前**正在执行的代码所在的段的特权级。**

**表示内核页和用户页的比特位是：U/S**

**作用是：**用户/超级用户标志。如果为1，那么运行在任何特权级上的程序都可以访问该页面。如果为0，那么页面只能被运行在超级用户特权级（0、1或2）上的程序访问。

## 第四题
**综合以上，386的分段的作用就是把很多（逻辑地址的）段，映射（就是设计DT中的描述符）到线性空间。这些段可以是内核段，也可以是用户段。在理解选段符寄存器、段描述符格式的基础上，尝试自己设计一种能够把内核（代码段和数据段）和一个用户任务（代码段和数据段）映射到一个4GB的线性空间的方案。只用GDT能做到吗？可尝试一下。怎么隔离内核和用户程序呢？**

可以做到。我们把段选择符号的TI位设置为0表示段描述符放在了GDT表中，然后通过将RPL设置为0、1分别表示内核的代码段和数据段；将PRL设置为2、3分别代表用户程序的代码段和数据段。这样用户程序无法访问内核的代码段和数据段，实现了内核和用户程序的隔离。

## 第五题
**在4题方案的基础上，把多个任务（代码段和数据段）和内核映射到一个线性空间的方案。只用GDT能做到吗？可尝试一下。怎么隔离内核和用户程序、用户程序和用户程序呢？**

不能。因为通过设置段选择符的RPL位的方式只能够区分内核和一个用户程序。当有多个用户程序时，需要通过GDT表指向不同的LDT表来分离不同的用户程序

## 第六题
**在4题的基础上，如果有多个任务（代码段和数据段），能不能分别（一个一个来）与内核映射一个独立的线性空间？因为是一个一个来，能不能共享一个段表（DT）呢？怎么隔离内核和用户程序、用户程序和用户程序呢？**

可以。每个任务的GDT和LDT可以单独为该任务划分一个独立的线性地址空间。将LDT的描述符存储在GDT中，然后通过LDTR来切换不同的任务，这样就可以共享一个GDT。由于每个任务拥有一个独立的LDT，且只能访问自身LDT以及GDT指向的段，因此可以隔离各个任务。

## 第七题
**以上4－6，线性空间怎么映射（页表）到物理空间呢？**

一级页表的情况下，使用线性空间的高20位进行匹配，低12位作为偏移量，同时根据内核和用户程序的不同对段描述符的u/s位进行设定，然后通过页表项的20位物理地址加上偏移量完成对物理空间的映射。

二级页表的情况下，使用前10位进行匹配目录，中间10位匹配具体的页表项，从中找出20位物理地址，加上偏移量完成对物理空间的映射。

![图片](https://uploader.shimo.im/f/It74zlmb5yUkMbed.png!thumbnail)

## 第八题
**想像一下，基于以上方案，2个任务的段和一个内核的段，加上分页后，在物理内存，可能是什么样子？**

任务的段加上了分段之后可以得到线性地址；加上了分页之后可以得到物理地址

![图片](https://uploader.shimo.im/f/Df9ZSPBSbBYzoKrK.png!thumbnail) 

